ttps://www.educative.io/page/5689413791121408/80001

 [다양한 속성들]

모든 노드는 
 현재 저장한 키 개수 n을 가짐
 키는 증가하도록 정렬되어 있음
 is_leaf:bool 가짐

 (리프가 아니면) 자식 노드(의 포인터)를 n+1 개를 가짐

 키는 각 서브트리에 저장된 키들의 범위를 분할한다. bst 느낌이지 뭐.

 모든 리프 노드는 동일한 깊이를 갖는다.
  
 노드가 포함할 수 있는 키 개수의 상한/하한이 있다.
    B트리는 최소 차수 t (>= 2)를 가진다.
    루트 외의 모든 노드는 t - 1개 이상(하한)의 키를 가진다.
        루트와 리프가 아닌 노드는 최소 t개 이상의 자식을 가진다.
        트리가 비어있지 않으면 루트는 최소 하나의 키를 가진다.
    모든 노드는 2t - 1개 이하(상한)의 키를 갖는다.
        노드는 최대 2t 개까지 자식노드를 가질 수 있다.
        꽉 찬 노드는 2t - 1개의 자식을 가진다.
    
    2-3-4 트리는 t=2인 경우이다. 모든 노드는 2,3, 혹은 4개의 자식 노드를 갖는다. 
 
B트리의 노드 수  n >= 1, 높이 h, 최소 차수가 t >= 2인 B-트리의 높이는..
h <= log_t((n + 1) / 2) 이다.
n >= 2*t^h - 1



성능 측정 방법
disk_read, disk_write
루트는 항상 메모리에 있어 disk_read 필요 없음
루트가 바뀌면 한번의 disk_write
노드가 한번이라도 사용되면 disk_read 필요(루트 제외)


검색
노드에서는 list.index를 이용, 위치를 알아낸다.
최종적으로는 노드와 인덱스를 반환

삽입
검색해서 노드, 위치를 알아내고, key를 삽입한다.
삽입 후 최대 키 이상의 키를 가질 경우, 스플릿을 진행한다.
재귀 호출이 반환되면서 스플릿이 계속 타고 올라갈 수 있다.
그래도 아무튼 O(log_t(n))임

삭제
검색해서 원소 찾음.

leaf
제거했을 때 key가 최소 개수(0) 이상이면 그냥 제거하면 됨
제거했을 때 key가 0개가 되면 sibling에서 key를 훔쳐와야 함. - 이 때 부모를 통해서 가져와야 함(회전?)

훔칠 sibling도 없다면? sibling과 merge를 한다.

있으면 삭제하고 부모 노드가 children이 부족하면 key를 내려보낸다?
재귀적으로 다음 부모도 children이 부족하면 key를 내려보낸다. 내려 보내면서 다른 child와 머지할 수 있다.

높이가 줄어드는 경우는?


 [제거]
leaf인 경우
    1. 2개 이상이면(> min): 그냥 제거  
    2. 1개면: sibling에서 가져와야 함.
internal인 경우





insert(node, key, max_n)
    idx := binsct(node.keys, key) #새 key가 들어갈 인덱스
    





















